%%________________________________________________________________________
%% LEIM | PROJETO
%% 2022 / 2013 / 2012
%% Modelo para relatório
%% v04: alteração ADEETC para DEETC; outros ajustes
%% v03: correção de gralhas
%% v02: inclui anexo sobre utilização sistema controlo de versões
%% v01: original
%% PTS / MAR.2022 / MAI.2013 / 23.MAI.2012 (construído)
%%________________________________________________________________________




%%________________________________________________________________________
\chapter{Introdução}
\label{ch:introducao}
%%________________________________________________________________________

Este trabalho visa criar um jogo em Unity \cite{Unity}, utilizando os conhecimentos adquiridos ao longo do semestre, nomeadamente geração procedimental, aprendizagem automática e interação Pessoa-Máquina.

O projeto consiste na criação de um mundo Minecraft \cite{Minecraft}, onde agentes são treinados a desempenhar determinadas tarefas e o jogador consegue interagir com o ambiente, modificando o curso dos acontecimentos.

Este documento está organizado da seguinte forma:

TODOTODOTODO esperar final e/ou confirmação led TODOTODOTODOTODO


%%________________________________________________________________________
\chapter{Ambiente}
\label{ch:ambiente}
%%________________________________________________________________________

Neste capítulo será ilustrado a forma como o terreno é criado, os tipos de blocos existentes no jogo, o aspeto do céu e os sons que gera.

%%________________________________________________________________________
\section{Terreno}
\label{sec:terreno}
%%________________________________________________________________________

A construção do terreno deste projeto é semelhante à do primeiro trabalho prático. Para ser possível termos um mundo infinito, é necessário este estar otimizado, de forma a diminuir o peso computacional. Assim, um mundo é criado continuamente em torno do agente à medida que este se movimenta e por conseguinte, parte do mundo é destruído quando este se afasta
consideravelmente.

Como dito anteriormente, este projeto visa a criação de um mundo
\emph{Minecraft} \cite{Minecraft}, ou seja um mundo baseado em cubos. Neste ambiente, existem
faces que não são visíveis ao jogador, mas que ao serem criadas e
renderizadas tornam a execução mais lenta. Assim, de forma a reduzir o
número de triângulos, vértices, etc, e melhorarmos o desempenho, não
processámos estas faces.

%%________________________________________________________________________
\subsection{Ruído de Perlin}
\label{subsec:ruidoperlin}
%%________________________________________________________________________

O ruído de Perlin \cite{PerlinNoise} é uma técnica muito usada em jogos e utiliza uma série
de números parcialmente aleatórios com o objetivo de imitar objetos naturais,
como o sol, nuvens, animações, terrenos, entre outros, e permite o controlo de
elementos em pequena e grande escala. Utilizamos este ruído de Perlin na nivelação do nosso terreno, ou seja quanto maior for a sua regularização, mais nivelado ficará o terreno.

TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO

METER VALOR QUE USAMOS E PORQUE - ainda não está bem definido so yea

TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO

%%________________________________________________________________________
\subsection{Algoritmo Flood Fill}
\label{subsec:floodfill}
%%________________________________________________________________________

De modo a ser possível construir os diferentes tipos de blocos,
utilizamos o algoritmo de Flood Fill \cite{FloodFill} que os desenha recursivamente. Em termos
gerais, este algoritmo determina a área conectada num nó, dado em um vetor
multi-dimensional de nós. Isto possibilita-nos a gerar mais do que um bloco do
mesmo tipo, criando assim blocos vizinhos.


%%________________________________________________________________________
\section{Blocos}
\label{sec:blocos}
%%________________________________________________________________________

tipos de blocos (grass, dirt, stone etc)

mostrar também texturas e materiais


%%________________________________________________________________________
\section{Skybox}
\label{sec:skybox}
%%________________________________________________________________________

mostrar aspeto final da skybox




%%________________________________________________________________________
\section{Mundo Escondido}
\label{subsec:mundoescondido}

De modo a dar uma funcionalidade extra ao jogo, existe um mundo que, inicialmente, se encontra escondido ao jogador. Para ser possível interagir com este mundo, é necessário colecionar 20 blocos de terra, 10 de pedra e 6 de diamante. Neste mundo é gerado de uma forma mais aleatória, onde octaves, smooth e persistence tomam diferentes valores e altera a skybox.

%%________________________________________________________________________

%%________________________________________________________________________
\section{Som}
\label{sec:som}
%%________________________________________________________________________

TODO TODO TODO
Falar do som, música ambiente + efeitos sonoros se metermos
TODO TODO TODO

%%________________________________________________________________________
\section{B-spline}
\label{sec:bspline}

De forma a preencher e embelezar o ambiente, foram colocados dragões a voar pelo céu. Isto foi possível com a inclusão de B-splines que definem a trajetória do dragão. Assim, enquanto o jogo estiver a decorrer, eles seguirão o trajeto e dão a sensação de vida ao jogo.

TODO TODO meter imagens TODO TODO

%%________________________________________________________________________

%%________________________________________________________________________
\chapter{Agentes}
\label{ch:agentes}
%%________________________________________________________________________

Aqui são identificados os agentes autónomos do projeto e a forma como foram treinados. 

%%________________________________________________________________________
\section{Variedade}
\label{sec:variedade}
%%________________________________________________________________________

Dois dos agentes autónomos são a presa e o predador. Ambos correspondem a aves, um pintassilgo e uma águia. O objetivo do predador é apanhar a presa, e da mesma forma, o pintassilgo tenta fugir da águia. O seu propósito é dar uma maior diversidade ao ambiente, permitindo ao jogador focar-se mais no mundo Minecraft. 


TODOTODOTODOTODOTODO
Meter imagens
TODOTODOTODOTODOTODO

Também foi reutilizado o agente do segundo trabalho prático. Durante a exploração do mundo, o jogador encontrará ovelhas treinadas a executar uma ação, nomeadamente irem até ao local correto.. 

TODOTODOTODOTODOTODO
Meter imagens
TODOTODOTODOTODOTODO


%%________________________________________________________________________
\section{ML-Agents}
\label{sec:mlagents}
%%________________________________________________________________________

O Unity Machine Learning Agents Toolkit (ML-Agents)  \cite{MLAgents} consiste num projeto de
código aberto, onde jogos e simulações podem servir como ambientes para efetuar o treino de agentes inteligentes. 

Os agentes autónomos foram assim treinados com esta ferramenta. Recorrendo a uma aprendizagem por reforço, os agentes conseguem identificar (através de Raycasts) o seu predador (no caso do pintassilgo) ou a sua presa (se for uma águia).

A metodologia de treinamento foi bastante simples: quando as diferentes aves se tocam, a águia recebe uma recompensa positiva e o pintassilgo uma negativa. o predador continuamente recebe uma penalização mínima, ao contrária da presa que é continuamente beneficiado. 


O ambiente das ovelhas consiste num plano onde o agente se consegue movimentar, quatro cubos escalados a fazer de paredes e três quads. Os dois mais afastados representam as duas possibilidades de resposta, e o central a informação necessária para o agente conseguir concluir a tarefa. Isto é, se o quad central for um O ele terá de tocar no O e se for um X
ele terá de tocar no X. A posição onde o agente começa é aleatória, no entanto é sempre antes do quad central (na metade do plano mais afastada dos dois quads - X e O). A imagem do quad central é aleatória podendo ser um X ou um círculo e os dois quads mais afastados são de
posição fixa. 

%%________________________________________________________________________
\section{Ficheiro de Configuração}
\label{sec:ficheiroconfiguracao}
%%________________________________________________________________________

De modo a treinar um agente, é necessário um ficheiro \aspas{. yaml} de configuração, onde é possível definir inúmeros parâmetros diferentes. O ficheiro utilizado encontra-se na figura \ref{fig:config}.

\begin{figure}[h]
	\centering
	\includegraphics{./config.png}
	\caption{Ficheiro de Configuração Presa e Predador}
	\label{fig:config}
\end{figure}

Devido ao número total de parâmetros possíveis definir ser muito elevado, iremos
dar uma breve explicação dos que foram utilizados neste trabalho:

\begin{itemize}
	\item batch size - número de experiências de cada iteração.
	\item buffer size - número de experiências colecionadas antes de atualizar o modelo;
	\item learning rate - corresponde à taxa de aprendizagem;
	\item Beta - corresponde à força de regularização entrópico. Quanto maior for este valor, mais ações aleatórias são tomadas;
	\item Epsilon - influencia a rapidez com que a política evolui durante o treino.	Estamos a utilizar o valor por omissão 0.2;
	\item Lambd - parâmetro de regularização com valor por defeito de 0.95.
	Significa o quão um agente depende dos valores atuais. Se este
	parâmetro possuir um valor baixo, significa que dependerá mais,
	enquanto que valores altos fazem com que dependa mais nas
	recompensas recebidas no ambiente
	\item Num epoch - também o valor por defeito 3, corresponde ao número de
	passagens a serem feitas pelo buffer ao realizar a otimização de descida
	de gradiente
	\item Learning rate schedule - para o nosso tipo de treino (ppo) o valor de
	defeito é linear. Este decrementa o learning rate de forma linear,
	chegando a 0 no \aspas{max steps};
	\item Normalize - valor booleano que diz se a normalização é aplicada ao
	vetor de observações de entrada;
	\item Hidden units - o range varia tipicamente entre 32 e 512, no nosso caso
	estamos a usar o valor 128 que é o valor por omissão. Este, corresponde
	ao número de unidades que estão completamente conectadas à
	camada da rede neural;
	\item Num layers - número de camadas escondidas na rede neural (valor por
	defeito é 2);
	\item Gamma - fator de desconto de recompensas futuras a vir do
	ambiente;
	\item Strength - fator a ser multiplicado pela recompensa dada pelo
	ambiente;
	\item keep checkpoints - número máximo de \aspas{pontos de controle} de modelos
	a manter. Estamos a usar o valor por defeito (5);
	\item Max steps - número total de passos que devem ser tomados no ambiente
	antes do treino terminar;
	\item Time horizon - Estamos a usar o valor por defeito (64). Significa o número
	de passos de experiência que cada agente coleciona antes de
	adicionar ao buffer;
	\item Summary freq - número de experiências que necessitam ser coletadas
	antes de gerar e mostrar as estatísticas de treino;
	
\end{itemize}

O ficheiro de configuração das ovelhas é possível ser visualizado na figura \ref{fig:hallway}.

\begin{figure}[h]
	\centering
	\includegraphics{./hallway.png}
	\caption{Ficheiro de Configuração Ovelhas}
	\label{fig:hallway}
\end{figure}

%%________________________________________________________________________
\chapter{Interface}
\label{ch:interface}
%%________________________________________________________________________

Este capítulo ilustra a interface do jogo.

%%________________________________________________________________________
\section{Menu}
\label{sec:menu}
%%________________________________________________________________________

TODO TODO TODO
mostrar o menu inicial e explicar a cena da voz
TODO TODO TODO

%%________________________________________________________________________
\section{Menu de Jogo}
\label{sec:menujogo}
%%________________________________________________________________________

mostrar o menu do jogo, os blocos e as opções etc

%%________________________________________________________________________
\chapter{Interação}
\label{ch:interacao}
%%________________________________________________________________________

Este capítulo trata a forma como o jogador interage com o ambiente, nomeadamente recorrendo ao teclado e microfone.

%%________________________________________________________________________
\section{Rato e Teclado}
\label{sec:teclado}
%%________________________________________________________________________

Com o movimento do rato, o jogador consegue ajustar a câmara e, caso um dos botões do rato seja premido (direito ou esquerdo), um cubo será criado ou destruído, respetivamente.

Caso o jogador possua quatro blocos de pedra, ele tem a possibilidade de criar uma picareta premindo a tecla M. Para facilitar a movimentação entre o mundo, consegue saltar clicando no espaço do teclado.


%%________________________________________________________________________
\section{Microfone}
\label{sec:microfone}
%%________________________________________________________________________

Para ser possível interagir com o jogo através de áudio, utilizou-se um exemplo dado na aula, nomeadamente se o microfone detetar um som acima de 40 decibéis e a concentração no pico da frequência for superior a um dado valor então assume-se que é um assobio e o jogador irá andar para a frente. 

Assobiar irá trocar o tipo de bloco que o jogador consegue construir. Estes alteram-se num ciclo predeterminado entre TODO TODO TODO terra pedra e ?? TODO TODO TODO

%%________________________________________________________________________
\chapter{Conclusão}
\label{ch:conclusao}
%%________________________________________________________________________

Pode-se concluir que os objetivos do projeto foram concluídos. Todos os temas lecionados ao longo do semestre foram agregados, nomeadamente geração procedimental com a construção de um mundo \emph{Minecraft} \cite{Minecraft}, aprendizagem automática onde diferentes agentes foram treinados e interação Pessoa-Máquina de modo a ser possível ao utilizador interagir e alterar o curso dos acontecimentos.  

Assim, foi possível consolidar os conhecimentos adquiridos ao longo das aulas, que já tinham sido postos em prática nos mini-projetos, em algo mais complexo e onde, havendo inúmeras funcionalidades adicionais que possam ser criadas, seja possível explorar estes conceitos livremente.

TODO TODO TODO TODO TODO TODO TODO TODO TODO 

não sei bem o que escrever mais, o segundo parágrafo já foi bue forçado xd talvez falar de dificuldades, cenas assim

TODO TODO TODO 

